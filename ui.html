<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        background-color: #FFFFFF;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        padding: 20px;
    }

    .title {
        font-size: 14px;
        font-weight: 500;
        color: rgba(0, 0, 0, 0.85);
        margin-bottom: 8px;
    }

    .description {
        font-size: 12px;
        font-weight: 400;
        color: rgba(0, 0, 0, 0.65);
        margin-bottom: 16px;
        line-height: 1.5;
    }

    .config-label {
        font-size: 12px;
        font-weight: 400;
        color: rgba(0, 0, 0, 0.65);
        margin-bottom: 8px;
    }

    .search-input {
        width: 100%;
        height: 32px;
        padding: 8px 12px;
        border: 1px solid rgba(0, 0, 0, 0.15);
        border-radius: 4px;
        font-size: 12px;
        font-family: inherit;
        outline: none;
        transition: border-color 0.2s;
        margin-bottom: 12px;
    }

    .search-input:focus {
        border-color: #2E74FF;
    }

    .preset-buttons {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
    }

    .preset-button {
        flex: 1;
        height: 28px;
        background-color: #F5F5F5;
        border: 1px solid rgba(0, 0, 0, 0.15);
        border-radius: 4px;
        font-size: 12px;
        font-weight: 400;
        color: rgba(0, 0, 0, 0.85);
        cursor: pointer;
        transition: all 0.2s;
    }

    .preset-button:hover {
        background-color: #E6F4FF;
        border-color: #2E74FF;
        color: #2E74FF;
    }

    .preset-button:active {
        background-color: #D4E8FF;
    }

    .fill-mode-section {
        margin-bottom: 16px;
    }

    .fill-mode-options {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .fill-mode-option {
        display: flex;
        align-items: center;
        cursor: pointer;
    }

    .fill-mode-option input[type="radio"] {
        margin-right: 8px;
        cursor: pointer;
    }

    .fill-mode-option label {
        font-size: 12px;
        color: rgba(0, 0, 0, 0.85);
        cursor: pointer;
    }

    .submit-button {
        width: 100%;
        height: 32px;
        background-color: #2E74FF;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 400;
        color: #FFFFFF;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .submit-button:hover {
        background-color: #1e5fcc;
    }

    .submit-button:active {
        background-color: #1550b3;
    }

    .submit-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    .message {
        font-size: 12px;
        font-weight: 400;
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 12px;
        display: none;
    }

    .message.show {
        display: block;
    }

    .message.loading {
        background-color: #E6F4FF;
        color: #2E74FF;
    }

    .message.success {
        background-color: #F6FFED;
        color: #52C41A;
    }

    .message.error {
        background-color: #FFF2E8;
        color: #FF7A45;
    }
</style>

<h1 class="title">图片填充</h1>
<p class="description">搜索高质量免费图片并填充到选中的形状图层中（建议使用英文关键词）</p>

<label class="config-label">搜索关键词</label>
<input type="text" class="search-input" id="searchInput" placeholder="请输入图片搜索关键词（建议英文）...">

<div class="preset-buttons">
    <button class="preset-button" id="avatarBtn">avatar</button>
    <button class="preset-button" id="productBtn">product</button>
</div>

<div class="fill-mode-section">
    <label class="config-label">填充模式</label>
    <div class="fill-mode-options">
        <div class="fill-mode-option">
            <input type="radio" id="fillModeFill" name="fillMode" value="FILL" checked>
            <label for="fillModeFill">居中裁剪（保持比例，缩放至最小一边覆盖）</label>
        </div>
        <div class="fill-mode-option">
            <input type="radio" id="fillModeStretch" name="fillMode" value="STRETCH">
            <label for="fillModeStretch">拉伸（强制填满，可能变形）</label>
        </div>
        <div class="fill-mode-option">
            <input type="radio" id="fillModeTile" name="fillMode" value="TILE">
            <label for="fillModeTile">平铺（按原尺寸重复）</label>
        </div>
    </div>
</div>

<div class="message" id="message"></div>
<button class="submit-button" id="submitBtn">搜索并填充</button>

<script>
    const searchInput = document.getElementById('searchInput');
    const avatarBtn = document.getElementById('avatarBtn');
    const productBtn = document.getElementById('productBtn');
    const submitBtn = document.getElementById('submitBtn');
    const message = document.getElementById('message');
    const fillModeRadios = document.querySelectorAll('input[name="fillMode"]');

    // 显示消息
    function showMessage(text, type) {
        message.textContent = text;
        message.className = 'message show ' + type;
    }

    // 隐藏消息
    function hideMessage() {
        message.className = 'message';
    }

    // 获取选中的填充模式
    function getFillMode() {
        const selected = document.querySelector('input[name="fillMode"]:checked');
        return selected ? selected.value : 'FILL';
    }

    // 预设按钮点击事件
    avatarBtn.addEventListener('click', function() {
        searchInput.value = 'avatar';
    });

    productBtn.addEventListener('click', function() {
        searchInput.value = 'product';
    });

    // 提交按钮点击事件
    submitBtn.addEventListener('click', function() {
        const keyword = searchInput.value.trim();
        if (!keyword) {
            showMessage('请输入搜索关键词', 'error');
            return;
        }

        // 禁用按钮并显示加载状态
        submitBtn.disabled = true;
        showMessage('正在搜索图片...', 'loading');

        // 向主线程发送消息
        parent.postMessage({ 
            pluginMessage: { 
                type: 'submit', 
                keyword: keyword,
                fillMode: getFillMode()
            } 
        }, '*');
    });

    // 接收来自主线程的消息
    window.onmessage = (event) => {
        console.log('UI: 收到window.onmessage事件:', event);
        console.log('UI: event.data:', event.data);
        console.log('UI: event.data.pluginMessage:', event.data.pluginMessage);
        
        // 主线程发送的消息可能在 event.data 中，也可能在 event.data.pluginMessage 中
        let msg = event.data.pluginMessage || event.data;
        if (!msg) {
            console.log('UI: 无法提取消息，忽略');
            return;
        }
        
        console.log('UI: 提取的消息:', msg);
        console.log('UI: 消息类型:', msg.type);

        // 处理 API 请求（主线程请求 UI 调用 API）
        if (msg.type === 'request-api') {
            console.log('UI: 收到API请求:', msg);
            showMessage(`正在搜索${msg.count}张图片...`, 'loading');
            
            callUnsplashAPI(msg.keyword, msg.count)
                .then(images => {
                    console.log('UI: API调用成功，发送结果给主线程');
                    // 将结果发送回主线程
                    parent.postMessage({ 
                        pluginMessage: { 
                            type: 'api-response', 
                            images: images,
                            fillMode: msg.fillMode
                        } 
                    }, '*');
                })
                .catch(error => {
                    console.error('UI: API调用失败:', error);
                    // 发送错误给主线程
                    parent.postMessage({ 
                        pluginMessage: { 
                            type: 'api-response', 
                            error: error.message || 'API调用失败' 
                        } 
                    }, '*');
                });
            return;
        }

        // 处理下载图片请求（主线程请求 UI 下载图片数据）
        if (msg.type === 'download-images') {
            console.log('UI: 收到下载图片请求:', msg);
            showMessage('正在下载图片...', 'loading');
            
            downloadImages(msg.images, msg.fillMode)
                .catch(error => {
                    console.error('UI: 下载图片失败:', error);
                    parent.postMessage({ 
                        pluginMessage: { 
                            type: 'error', 
                            error: error.message || '下载图片失败' 
                        } 
                    }, '*');
                });
            return;
        }

        submitBtn.disabled = false;

        if (msg.type === 'loading') {
            showMessage(msg.message || '正在处理...', 'loading');
        } else if (msg.type === 'success') {
            showMessage(msg.message || '操作成功', 'success');
            // 3秒后隐藏成功消息
            setTimeout(() => {
                hideMessage();
            }, 3000);
        } else if (msg.type === 'error') {
            showMessage(msg.message || '操作失败', 'error');
        }
    };

    // Vercel 代理 API URL
    const PROXY_URL = 'https://textfill-ten.vercel.app/api/unsplash-proxy';

    // 调用 Unsplash API 搜索图片（在 UI 中调用，因为可以使用 fetch）
    async function callUnsplashAPI(keyword, count) {
        try {
            console.log('UI: 开始调用代理API:', PROXY_URL);
            console.log('UI: 请求参数:', { keyword, count });
            
            console.log('UI: 发送fetch请求...');
            
            // 创建 AbortController 用于超时控制
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 60000); // 60秒超时
            
            let response;
            try {
                response = await fetch(PROXY_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        keyword: keyword,
                        count: count
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
            } catch (fetchError) {
                clearTimeout(timeoutId);
                if (fetchError.name === 'AbortError') {
                    throw new Error('请求超时，请检查网络连接或稍后重试');
                }
                throw fetchError;
            }
            
            console.log('UI: 收到响应:', response.status, response.statusText);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('UI: API响应错误:', response.status, errorText);
                let errorData = {};
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    errorData = { error: errorText };
                }
                throw new Error(errorData.error || `API请求失败: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('UI: API返回数据:', data);
            
            if (!data.success || !data.images || !Array.isArray(data.images)) {
                throw new Error(data.error || 'API返回数据格式错误');
            }
            
            if (data.images.length < count) {
                throw new Error(`搜索到的图片数量不足，需要${count}张，实际找到${data.images.length}张`);
            }
            
            console.log('UI: 成功获取图片:', data.images);
            return data.images;
        } catch (error) {
            console.error('UI: 调用代理API失败:', error);
            if (error.message.includes('Failed to fetch') || error.message.includes('timeout') || error.message.includes('ERR_CONNECTION_TIMED_OUT')) {
                throw new Error('无法连接到服务器，请检查网络连接或稍后重试。如果问题持续，可能是 Vercel 代理服务器无法访问。');
            }
            throw error;
        }
    }

    // 下载图片数据并发送给主线程
    async function downloadImages(images, fillMode) {
        try {
            for (let i = 0; i < images.length; i++) {
                const image = images[i];
                console.log(`UI: 开始下载图片 ${i + 1}/${images.length}: ${image.url}`);
                showMessage(`正在下载图片 ${i + 1}/${images.length}...`, 'loading');
                
                // 下载图片
                const response = await fetch(image.url);
                if (!response.ok) {
                    throw new Error(`下载图片失败: ${response.status}`);
                }
                
                // 转换为 ArrayBuffer，再转为 Uint8Array
                const arrayBuffer = await response.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                console.log(`UI: 图片 ${i} 下载完成，大小: ${uint8Array.length} bytes`);
                
                // 发送图片数据给主线程
                parent.postMessage({ 
                    pluginMessage: { 
                        type: 'image-data', 
                        imageData: Array.from(uint8Array), // 转换为普通数组以便序列化
                        fillMode: fillMode,
                        index: i
                    } 
                }, '*');
            }
            
            console.log('UI: 所有图片下载完成');
        } catch (error) {
            console.error('UI: 下载图片时出错:', error);
            throw error;
        }
    }
</script>
